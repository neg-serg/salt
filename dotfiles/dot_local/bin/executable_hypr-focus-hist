#!/usr/bin/env python3
"""Track Hyprland window focus history via IPC and switch to previous window.

Daemon mode (default): listens to activewindowv2/closewindow events on the
Hyprland event socket, maintains an ordered focus history, and writes the
previous window address to a state file.

Switch mode (--switch): reads the state file and focuses the previous window.
"""

from __future__ import annotations

import os
import socket
import subprocess
import sys


def socket_dir() -> str:
    sig = os.environ.get("HYPRLAND_INSTANCE_SIGNATURE", "")
    runtime = os.environ.get("XDG_RUNTIME_DIR", f"/run/user/{os.getuid()}")
    d = f"{runtime}/hypr/{sig}"
    if os.path.isdir(d):
        return d
    return f"/tmp/hypr/{sig}"


def state_path() -> str:
    return f"{socket_dir()}/focus-history"


def switch() -> int:
    """Read previous window address from state file and focus it."""
    path = state_path()
    try:
        with open(path) as f:
            addr = f.read().strip()
    except FileNotFoundError:
        return 1
    if not addr:
        return 1
    subprocess.run(
        ["hyprctl", "dispatch", "focuswindow", f"address:{addr}"],
        check=False,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    return 0


def daemon() -> None:
    """Listen to Hyprland events and track focus history."""
    sd = socket_dir()
    path = state_path()

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(f"{sd}/.socket2.sock")

    # Ordered list of window addresses, most recent last.
    history: list[str] = []

    buf = b""
    while True:
        data = sock.recv(4096)
        if not data:
            break
        buf += data
        while b"\n" in buf:
            line, buf = buf.split(b"\n", 1)
            event = line.decode(errors="replace")

            if event.startswith("activewindowv2>>"):
                hex_addr = event[16:]
                if not hex_addr:
                    continue
                addr = f"0x{hex_addr}"
                # Skip if already the most recent
                if history and history[-1] == addr:
                    continue
                # Move to end (re-insert)
                if addr in history:
                    history.remove(addr)
                history.append(addr)
                # Cap history size
                if len(history) > 20:
                    history = history[-20:]
                # Write previous window to state file
                if len(history) >= 2:
                    with open(path, "w") as f:
                        f.write(history[-2])

            elif event.startswith("closewindow>>"):
                hex_addr = event[13:]
                addr = f"0x{hex_addr}"
                history = [h for h in history if h != addr]
                if len(history) >= 2:
                    with open(path, "w") as f:
                        f.write(history[-2])
                elif history:
                    with open(path, "w") as f:
                        f.write(history[0])
                else:
                    try:
                        os.remove(path)
                    except FileNotFoundError:
                        pass


def main() -> int:
    if "--switch" in sys.argv:
        return switch()
    daemon()
    return 0


if __name__ == "__main__":
    sys.exit(main())
