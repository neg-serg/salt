#!/usr/bin/env python3
import sys
import re
import argparse
from collections import defaultdict, OrderedDict

# Matches: ${FAST_HIGHLIGHT_STYLES[key]:=value}
STYLE_RE = re.compile(r"\$\{FAST_HIGHLIGHT_STYLES\[([^\]]+)\]:=([^}]+)\}")

# Matches: typeset ... FAST_THEME_NAME=...
TNAME_TYPES_RE = re.compile(
    r'^\s*typeset(?:\s+-g)?\s+FAST_THEME_NAME\s*=\s*"?([^"]+)"?'
)

# Matches: zstyle :plugin:fast-syntax-highlighting theme ...
TNAME_ZSTYLE_RE = re.compile(
    r'^\s*zstyle\s+:plugin:fast-syntax-highlighting\s+theme\s+"?([^"]+)"?'
)


def trim(s: str) -> str:
    """Trim whitespace from both ends."""
    return s.strip()


def dequote(s: str) -> str:
    """Remove single/double quotes if present around the string."""
    s = s.strip()
    if (s.startswith('"') and s.endswith('"')) or (
        s.startswith("'") and s.endswith("'")
    ):
        return s[1:-1]
    return s


def parse_file(path: str):
    """
    Parse theme file and extract:
    - raw: OrderedDict of key -> style for all entries
    - theme_detected: theme name (if found)
    - matches: number of style matches found
    """
    raw = OrderedDict()
    theme_detected = None
    matches = 0

    with open(path, "r", encoding="utf-8") if path != "-" else sys.stdin as f:
        for line in f:
            # Remove trailing inline comment starting with '#'
            if "#" in line:
                line = line.split("#", 1)[0]
            line = line.strip()
            if not line:
                continue

            # Detect theme name from typeset or zstyle
            m = TNAME_TYPES_RE.search(line)
            if m:
                theme_detected = dequote(m.group(1))
                continue
            m = TNAME_ZSTYLE_RE.search(line)
            if m:
                theme_detected = dequote(m.group(1))
                continue

            # Match style assignment lines
            m = STYLE_RE.search(line)
            if m:
                key = trim(m.group(1))
                val = trim(m.group(2))
                matches += 1
                # Keep the first occurrence (later overridden if keep_last=True)
                if key not in raw:
                    raw[key] = val
                else:
                    pass  # Will handle duplicates later if keep_last is set

    return raw, theme_detected, matches


def compress(raw, theme, drop_nones=False, keep_last=False, min_group=2):
    """
    Compress theme data:
    - Optionally keep only the last duplicate entry
    - Group file extensions by style for batch _setstyle loops
    """
    if keep_last:
        # Reverse traversal so the last occurrence wins
        last = OrderedDict()
        for k in reversed(list(raw.keys())):
            last[k] = raw[k]
        raw = OrderedDict(reversed(list(last.items())))

    gen = OrderedDict()  # Non-extension theme keys
    ext2style = OrderedDict()  # ext -> style

    for k, v in raw.items():
        if drop_nones and v == "none":
            continue
        if k.startswith(f"{theme}file-extensions-"):
            ext = k[len(f"{theme}file-extensions-") :].lower()
            if ext not in ext2style:
                ext2style[ext] = v
            else:
                pass  # Ignore duplicates unless keep_last was applied earlier
        elif k.startswith(theme):
            if k not in gen:
                gen[k] = v

    # Group extensions by identical style
    style_groups = defaultdict(list)
    for ext, st in ext2style.items():
        style_groups[st].append(ext)

    # Deduplicate and sort for deterministic output
    for st in style_groups:
        style_groups[st] = sorted(set(style_groups[st]))

    return gen, style_groups


def emit(theme, gen, style_groups, min_group, out):
    """Emit compressed theme as Zsh script."""
    w = out.write
    w("### Generated by compress_theme.py â€” do not hand-edit\n")
    w(f"typeset -g FAST_THEME_NAME={theme}\n\n")
    w("typeset -gA FAST_HIGHLIGHT_STYLES=(\n")
    for k, v in gen.items():
        w(f"  [{k}]='{v}'\n")
    w(")\n\n")
    w(
        "_setstyle(){ local k=$1 v=$2; [[ -n ${FAST_HIGHLIGHT_STYLES[$k]-} ]] || FAST_HIGHLIGHT_STYLES[$k]=$v; }\n\n"
    )
    for style, exts in style_groups.items():
        if len(exts) >= min_group:
            w(
                f"for ext in {' '.join(exts)}; do _setstyle \"${{FAST_THEME_NAME}}file-extensions-$ext\" '{style}'; done\n"
            )
        else:
            for e in exts:
                w(
                    f"_setstyle \"${{FAST_THEME_NAME}}file-extensions-{e}\" '{style}'\n"
                )
    w("# ðŸ¥Ÿ pie")


def main():
    ap = argparse.ArgumentParser(description="Compress F-Sy-H theme file")
    ap.add_argument("input", help="input theme file (or - for stdin)")
    ap.add_argument("--theme", help="override theme name")
    ap.add_argument(
        "--drop-nones",
        action="store_true",
        help="drop entries with style 'none'",
    )
    ap.add_argument(
        "--keep-last", action="store_true", help="last wins on duplicates"
    )
    ap.add_argument(
        "--min-group",
        type=int,
        default=2,
        help="min group size to emit a loop",
    )
    args = ap.parse_args()

    raw, detected, matches = parse_file(args.input)
    theme = args.theme or detected or "neg"
    if matches == 0:
        print(
            "# ERROR: nothing recognized. Expected lines like ${FAST_HIGHLIGHT_STYLES[...]:=...}",
            file=sys.stderr,
        )
        sys.exit(1)

    gen, style_groups = compress(
        raw,
        theme,
        drop_nones=args.drop_nones,
        keep_last=args.keep_last,
        min_group=args.min_group,
    )
    emit(theme, gen, style_groups, args.min_group, sys.stdout)


if __name__ == "__main__":
    main()
