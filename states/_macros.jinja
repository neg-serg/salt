{# Reusable Salt state macros for common patterns #}

{# Trigger systemd daemon-reload when listed states change.
   Usage: {{ daemon_reload('unbound', ['cmd: install_unbound', 'file: unbound_override']) }}
#}
{%- macro daemon_reload(name, onchanges) -%}
{{ name }}_daemon_reload:
  cmd.run:
    - name: systemctl daemon-reload
    - onchanges:
{%- for item in onchanges %}
      - {{ item }}
{%- endfor %}
{%- endmacro -%}

{# Download binary directly to ~/.local/bin/ and chmod +x.
   Usage: {{ curl_bin('aliae', 'https://github.com/.../aliae-linux-amd64') }}
          {{ curl_bin('xdg-ninja', 'https://github.com/.../xdgnj') }}
#}
{%- macro curl_bin(name, url, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: curl -fsSL {{ url }} -o ~/.local/bin/{{ name }} && chmod +x ~/.local/bin/{{ name }}
    - runas: {{ user }}
    - creates: {{ home }}/.local/bin/{{ name }}
{%- endmacro -%}

{# Download tar.gz, extract single binary to ~/.local/bin/.
   Usage: {{ github_tar('eza', 'https://github.com/.../eza_x86_64.tar.gz') }}
#}
{%- macro github_tar(name, url, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        TMPDIR=$(mktemp -d)
        curl -fsSL {{ url }} -o "$TMPDIR/archive.tar.gz"
        tar -xzf "$TMPDIR/archive.tar.gz" -C "$TMPDIR"
        find "$TMPDIR" -name '{{ name }}' -type f -exec install -m755 {} ~/.local/bin/{{ name }} \;
        rm -rf "$TMPDIR"
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ home }}/.local/bin/{{ name }}
{%- endmacro -%}

{# Download latest GitHub release asset to ~/.local/bin/.
   Fetches TAG via GitHub API, supports direct binary or tar.gz.
   Usage: {{ github_release('sops', 'getsops/sops', 'sops-${TAG}.linux.amd64') }}
          {{ github_release('rmpc', 'mierak/rmpc', 'rmpc-${TAG}-x86_64.tar.gz', format='tar.gz') }}
          {{ github_release('sing-box', 'SagerNet/sing-box', 'sing-box-${VER}.tar.gz', format='tar.gz', strip_v=True) }}
#}
{%- macro github_release(name, repo, asset, bin=None, format='bin', strip_v=False, user='neg', home='/home/neg') -%}
{%- set target = bin or name -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        TAG=$(curl -fsSIL -o /dev/null -w '%{url_effective}' https://github.com/{{ repo }}/releases/latest | grep -oP '[^/]+$')
{%- if strip_v %}
        VER=${TAG#v}
{%- endif %}
{%- if format == 'bin' %}
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o ~/.local/bin/{{ target }}
        chmod +x ~/.local/bin/{{ target }}
{%- elif format == 'tar.gz' %}
        TMPDIR=$(mktemp -d)
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o "$TMPDIR/archive.tar.gz"
        tar -xzf "$TMPDIR/archive.tar.gz" -C "$TMPDIR"
        find "$TMPDIR" -name '{{ target }}' -type f -exec install -m755 {} ~/.local/bin/{{ target }} \;
        rm -rf "$TMPDIR"
{%- endif %}
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ home }}/.local/bin/{{ target }}
{%- endmacro -%}

{# Download latest GitHub release asset to /usr/local/bin/ (system-level).
   Like github_release but runs as root, no runas. Supports zip and tar.gz.
   src_bin: filename of the binary inside the archive (default: name).
   Usage: {{ github_release_system('loki', 'grafana/loki', 'loki-linux-amd64.zip', src_bin='loki-linux-amd64') }}
          {{ github_release_system('adguardhome', 'AdguardTeam/AdGuardHome', 'AdGuardHome_linux_amd64.tar.gz', src_bin='AdGuardHome', format='tar.gz') }}
#}
{%- macro github_release_system(name, repo, asset, src_bin=None, format='zip', dest='/usr/local/bin') -%}
{%- set source_bin = src_bin or name -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        TAG=$(curl -fsSIL -o /dev/null -w '%{url_effective}' https://github.com/{{ repo }}/releases/latest | grep -oP '[^/]+$')
{%- if format == 'zip' %}
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o /tmp/{{ name }}.zip
        unzip -o /tmp/{{ name }}.zip -d /tmp
        install -m 0755 /tmp/{{ source_bin }} {{ dest }}/{{ name }}
        rm -f /tmp/{{ name }}.zip /tmp/{{ source_bin }}
{%- elif format == 'tar.gz' %}
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o /tmp/{{ name }}.tar.gz
        tar -xzf /tmp/{{ name }}.tar.gz -C /tmp
        find /tmp -maxdepth 3 -name '{{ source_bin }}' -type f -exec install -m 0755 {} {{ dest }}/{{ name }} \;
        rm -rf /tmp/{{ name }}.tar.gz /tmp/{{ source_bin }}*
{%- endif %}
    - shell: /bin/bash
    - creates: {{ dest }}/{{ name }}
{%- endmacro -%}

{# pipx install (PEP 668 compatible).
   Usage: {{ pip_pkg('httpstat') }}
          {{ pip_pkg('neovim_python_deps', pkg='neovim-remote', bin='nvr') }}
#}
{%- macro pip_pkg(name, pkg=None, bin=None, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: pipx install {{ pkg or name }}
    - runas: {{ user }}
    - creates: {{ home }}/.local/bin/{{ bin or name }}
{%- endmacro -%}

{# cargo install (crates.io or git).
   Usage: {{ cargo_pkg('handlr', pkg='handlr-regex') }}
          {{ cargo_pkg('agg', git='https://github.com/asciinema/agg') }}
          {{ cargo_pkg('pzip', bin='pz') }}
#}
{%- macro cargo_pkg(name, pkg=None, bin=None, git=None, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: cargo install {{ '--git ' ~ git if git else pkg or name }}
    - runas: {{ user }}
    - creates: {{ home }}/.local/share/cargo/bin/{{ bin or name }}
{%- endmacro -%}

{# Install packages via pacman (CachyOS/Arch).
   check defaults to first package. requires is an optional list of requisites.
   Usage: {{ pacman_install('unbound', 'unbound') }}
          {{ pacman_install('jellyfin', 'jellyfin-server jellyfin-web') }}
#}
{%- macro pacman_install(name, pkgs, check=None, requires=None) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: pacman -S --noconfirm --needed {{ pkgs }}
    - unless: pacman -Q {{ check or pkgs.split()[0] }}
{%- if requires %}
    - require:
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endmacro -%}

{# Build and install a package from a local PKGBUILD via file.recurse + makepkg + pacman -U.
   source: salt:// path to PKGBUILD directory. check: custom `unless` command (default: pacman -Q name).
   Usage: {{ pkgbuild_install('raise', 'salt://build/pkgbuilds/raise', user='neg') }}
          {{ pkgbuild_install('iosevka-neg-fonts', 'salt://build/pkgbuilds/iosevka-neg-fonts', user='neg', timeout=7200) }}
#}
{%- macro pkgbuild_install(name, source, user='neg', build_base='/tmp/pkgbuild', timeout=600, check=None) -%}
{%- set safe = name | replace('-', '_') -%}
{{ safe }}_pkgbuild:
  file.recurse:
    - name: {{ build_base }}/{{ name }}
    - source: {{ source }}
    - makedirs: True
    - user: {{ user }}
    - group: {{ user }}

build_{{ safe }}:
  cmd.run:
    - name: |
        set -eo pipefail
        su - {{ user }} -c 'cd {{ build_base }}/{{ name }} && makepkg -sf --noconfirm'
        pacman -U --noconfirm --needed {{ build_base }}/{{ name }}/*.pkg.tar.zst
        rm -rf {{ build_base }}/{{ name }}
    - shell: /bin/bash
    - timeout: {{ timeout }}
    - unless: {{ check or 'pacman -Q ' ~ name }}
    - require:
      - file: {{ safe }}_pkgbuild
{%- endmacro -%}

{# Create system daemon user + data directory.
   Consolidates: user.present (system user, nologin shell) + file.directory (homedir/datadir with ownership).
   shell defaults to /usr/sbin/nologin. createhome defaults to False (createhome by file.directory instead).
   Usage: {{ system_daemon_user('loki', '/var/lib/loki') }}
          {{ system_daemon_user('adguardhome', '/var/lib/adguardhome') }}
          {{ system_daemon_user('bitcoind', '/var/lib/bitcoind', requires=['cmd: install_bitcoind']) }}
#}
{%- macro system_daemon_user(name, home_dir, shell='/usr/sbin/nologin', requires=None) -%}
{{ name }}_user:
  user.present:
    - name: {{ name }}
    - system: True
    - shell: {{ shell }}
    - home: {{ home_dir }}
    - createhome: False

{{ name }}_data_dir:
  file.directory:
    - name: {{ home_dir }}
    - user: {{ name }}
    - group: {{ name }}
    - makedirs: True
    - require:
      - user: {{ name }}_user
{%- if requires %}
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endmacro -%}

{# Wrap cmd.run with standardized error handling. Provides shell helper functions for
   consistent error messages, timestamped status output, and clean failure reporting.
   Useful for complex multi-step operations (installs, builds, configuration).
   Usage:
   {% call run_with_error_context('install_foo', requires=['cmd: install_bar']) %}
   source /build/salt/error-helpers.sh
   step "Downloading foo"
   curl -fsSL https://example.com/foo -o /tmp/foo
   run_step "Installing foo" install -m755 /tmp/foo ~/.local/bin/
   success "Foo installed"
   {% endcall %}
#}
{%- macro run_with_error_context(state_id, requires=None, creates=None, shell='/bin/bash') -%}
{{ state_id }}:
  cmd.run:
    - name: |
        set -uo pipefail
        step() { printf "[%s] %s\n" "$(date +'%H:%M:%S')" "$*"; }
        success() { printf "[  âœ“  ] %s\n" "$*"; }
        trap 'echo "[EXIT] Cleanup on exit (code: $?)" >&2' EXIT
        {{ caller() | indent(8) }}
    - shell: {{ shell }}
{% if creates %}
    - creates: {{ creates }}
{% endif %}
{% if requires %}
    - require:
{% for req in requires %}
      - {{ req }}
{% endfor %}
{% endif %}

{%- endmacro -%}

{# Download and extract tar.gz/tar.xz archive, move binary(ies) to ~/.local/bin/.
   Supports: TAG fetching, nested directories, multiple binaries, optional chmod.
   archive_ext: tar.gz (default) | tar.xz. fetch_tag: True (default False) to fetch latest ${TAG} from GitHub API.
   binary_pattern: path pattern for finding binaries after extraction (e.g., "nu-*/nu" or "streaming_extractor_music").
   binaries: optional list of binary names to move. If None, uses basename of binary_pattern.
   chmod: True (default False) to chmod +x extracted binaries.
   Usage: {{ curl_extract_tar('nushell', 'https://github.com/nushell/nushell/releases/latest/download/nu-${TAG}-x86_64-unknown-linux-musl.tar.gz', 'nu-*/nu', fetch_tag=True) }}
          {{ curl_extract_tar('hyprevents', 'https://github.com/vilari-mickopf/hyprevents/archive/refs/heads/master.tar.gz', 'hyprevents/hyprevents', binaries=['hyprevents', 'event_handler', 'event_loader']) }}
#}
{%- macro curl_extract_tar(name, url, binary_pattern, archive_ext='tar.gz', fetch_tag=False, binaries=None, chmod=False, user='neg', home='/home/neg') -%}
{%- set ext_flag = 'J' if archive_ext == 'tar.xz' else 'z' -%}
{%- if fetch_tag %}
{%- if '/api.github.com/repos/' in url %}
{%- set repo_path = url.split('/repos/')[1].split('/')[0:2] | join('/') %}
{%- else %}
{%- set repo_path = url.split('github.com/')[1].split('/')[0:2] | join('/') %}
{%- endif %}
{%- endif %}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
{%- if fetch_tag %}
        TAG=$(curl -fsSIL -o /dev/null -w '%{url_effective}' https://github.com/{{ repo_path }}/releases/latest | grep -oP '[^/]+$')
{%- endif %}
        curl -fsSL "{{ url }}" -o /tmp/{{ name }}.{{ archive_ext }}
        tar -x{{ ext_flag }}f /tmp/{{ name }}.{{ archive_ext }} -C /tmp
{%- if binaries %}
{% for bin in binaries %}
        mv /tmp/{{ binary_pattern.replace('*', bin) if '*' in binary_pattern else binary_pattern }}/{{ bin }} ~/.local/bin/ 2>/dev/null || mv /tmp/{{ binary_pattern.rsplit('/', 1)[0] }}/{{ bin }} ~/.local/bin/
{%- endfor %}
{%- else %}
        find /tmp -maxdepth 3 -path "*{{ binary_pattern }}*" -type f ! -name "*.tar*" -exec install -m755 {} ~/.local/bin/{{ binary_pattern.rsplit('/', 1)[-1] }} \;
{%- endif %}
{%- if chmod %}
        chmod +x ~/.local/bin/{{ binaries[0] if binaries else binary_pattern.rsplit('/', 1)[-1] }}
{%- endif %}
        rm -rf /tmp/{{ name }}.{{ archive_ext }} /tmp/{{ name }}-* /tmp/{{ name }}
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ home }}/.local/bin/{{ binaries[0] if binaries else binary_pattern.rsplit('/', 1)[-1] }}

{%- endmacro -%}

{# Download and extract ZIP archive, move binary(ies) to ~/.local/bin/.
   Supports: nested directories, multiple binaries, optional chmod.
   binary_path: path pattern relative to extraction dir (e.g., "yazi-x86_64-unknown-linux-musl/yazi").
   binaries: optional list of binaries to move. If None, uses last part of binary_path.
   chmod: True (default False) to chmod +x extracted binaries.
   Usage: {{ curl_extract_zip('xray', 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip', 'xray/xray', chmod=True) }}
          {{ curl_extract_zip('yazi', 'https://github.com/sxyazi/yazi/releases/latest/download/yazi-x86_64-unknown-linux-musl.zip', 'yazi-x86_64-unknown-linux-musl', binaries=['yazi', 'ya']) }}
#}
{%- macro curl_extract_zip(name, url, binary_path, binaries=None, chmod=False, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        curl -fsSL "{{ url }}" -o /tmp/{{ name }}.zip
        unzip -o /tmp/{{ name }}.zip -d /tmp/{{ name }}_extracted
{%- if binaries %}
{%- for bin in binaries %}
        mv /tmp/{{ name }}_extracted/{{ binary_path }}/{{ bin }} ~/.local/bin/
{%- endfor %}
{%- else %}
        mv /tmp/{{ name }}_extracted/{{ binary_path }} ~/.local/bin/{{ binary_path.rsplit('/', 1)[-1] }}
{%- endif %}
{%- if chmod %}
        chmod +x ~/.local/bin/{{ binaries[0] if binaries else binary_path.rsplit('/', 1)[-1] }}
{%- endif %}
        rm -rf /tmp/{{ name }}.zip /tmp/{{ name }}_extracted
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ home }}/.local/bin/{{ binaries[0] if binaries else binary_path.rsplit('/', 1)[-1] }}


{%- endmacro -%}

{# Deploy inline systemd user unit file (~/.config/systemd/user/).
   Callable macro: unit content goes inside {% call %} block.
   Usage:
   {% call user_service('mbsync_gmail_service', 'mbsync-gmail.service', user=user, home=home) %}
   [Unit]
   Description=Mailbox synchronization (Gmail)
   [Service]
   Type=oneshot
   ExecStart=/usr/bin/mbsync -c %h/.config/mbsync/mbsyncrc gmail
   [Install]
   WantedBy=default.target
   {% endcall %}
#}
{%- macro user_service(name, filename, user='neg', home='/home/neg') -%}
{{ name }}:
  file.managed:
    - name: {{ home }}/.config/systemd/user/{{ filename }}
    - user: {{ user }}
    - group: {{ user }}
    - mode: '0644'
    - makedirs: True
    - contents: |
{{ caller() | trim | indent(8, first=True) }}
{%- endmacro -%}

{# Download and install a font from a ZIP archive to ~/.local/share/fonts/<subdir>.
   Creates the target directory, downloads/unzips, runs fc-cache, cleans up.
   Usage: {{ download_font_zip('sf_pro_display', 'https://font.download/dl/font/sf-pro-display.zip', 'SFProDisplay') }}
          {{ download_font_zip('anurati', 'https://font.download/dl/font/anurati.zip', 'Anurati') }}
#}
{%- macro download_font_zip(name, url, subdir, user='neg', home='/home/neg') -%}
{%- set fonts_dir = home ~ '/.local/share/fonts' -%}
{{ fonts_dir }}/{{ subdir }}:
  file.directory:
    - user: {{ user }}
    - group: {{ user }}
    - makedirs: True

install_{{ name }}:
  cmd.run:
    - name: |
        set -eo pipefail
        curl -fsSL '{{ url }}' -o /tmp/{{ name }}.zip
        unzip -o /tmp/{{ name }}.zip -d {{ fonts_dir }}/{{ subdir }}
        fc-cache -f {{ fonts_dir }}/{{ subdir }}
        rm -f /tmp/{{ name }}.zip
    - runas: {{ user }}
    - shell: /bin/bash
    - unless: "ls {{ fonts_dir }}/{{ subdir }}/*.otf 2>/dev/null || ls {{ fonts_dir }}/{{ subdir }}/*.ttf 2>/dev/null"
    - require:
      - file: {{ fonts_dir }}/{{ subdir }}
{%- endmacro -%}

{# Deploy systemd unit file + enable service (file + daemon-reload + service.enabled + optional service.running).
   unit_type: 'service' (default) | 'timer' | 'socket' | etc.
   running: True (default False) to add service.running after enabled for auto-start behavior.
   requires: optional list of state requisites (includes daemon-reload as base requirement).
   Usage: {{ service_with_unit('loki', 'salt://units/loki.service', requires=['cmd: install_loki', 'file: loki_config']) }}
          {{ service_with_unit('fancontrol', 'salt://units/fancontrol.service', running=True, requires=['file: fancontrol_service', 'cmd: install_fancontrol']) }}
#}
{%- macro service_with_unit(name, source, unit_type='service', running=False, requires=None) -%}
{{ name }}_service:
  file.managed:
    - name: /etc/systemd/system/{{ name }}.{{ unit_type }}
    - mode: '0644'
    - source: {{ source }}

{{ name }}_daemon_reload:
  cmd.run:
    - name: systemctl daemon-reload
    - onchanges:
      - file: {{ name }}_service

{{ name }}_enabled:
  service.enabled:
    - name: {{ name }}
    - require:
      - cmd: {{ name }}_daemon_reload
{%- if requires %}
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}

{%- if running %}
{{ name }}_running:
  service.running:
    - name: {{ name }}
    - watch:
      - file: {{ name }}_service
    - require:
      - service: {{ name }}_enabled
{%- endif %}
{%- endmacro -%}
