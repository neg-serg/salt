{# Reusable Salt state macros for common patterns #}

{# Clear failed state + ensure service is running with config watches.
   Emits two states: {{ name }}_reset_failed and {{ name }}_running.
   Usage: {{ ensure_running('unbound', watch=['file: unbound_config']) }}
          {{ ensure_running('adguardhome', watch=['file: adguardhome_service']) }}
#}
{%- macro ensure_running(name, watch=None) -%}
{{ name }}_reset_failed:
  cmd.run:
    - name: systemctl reset-failed {{ name }} 2>/dev/null; true
    - onlyif: systemctl is-failed {{ name }}
    - require:
      - service: {{ name }}_enabled

{{ name }}_running:
  service.running:
    - name: {{ name }}
{%- if watch %}
    - watch:
{%- for w in watch %}
      - {{ w }}
{%- endfor %}
{%- endif %}
    - require:
      - service: {{ name }}_enabled
      - cmd: {{ name }}_reset_failed
{%- endmacro -%}

{# Trigger systemd daemon-reload when listed states change.
   Usage: {{ daemon_reload('unbound', ['cmd: install_unbound', 'file: unbound_override']) }}
#}
{%- macro daemon_reload(name, onchanges) -%}
{{ name }}_daemon_reload:
  cmd.run:
    - name: systemctl daemon-reload
    - onchanges:
{%- for item in onchanges %}
      - {{ item }}
{%- endfor %}
{%- endmacro -%}

{# Download binary directly to ~/.local/bin/ and chmod +x.
   Usage: {{ curl_bin('aliae', 'https://github.com/.../aliae-linux-amd64') }}
          {{ curl_bin('xdg-ninja', 'https://github.com/.../xdgnj') }}
#}
{%- macro curl_bin(name, url, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: curl -fsSL {{ url }} -o ~/.local/bin/{{ name }} && chmod +x ~/.local/bin/{{ name }}
    - runas: {{ user }}
    - creates: {{ home }}/.local/bin/{{ name }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# Download tar.gz, extract single binary to ~/.local/bin/.
   Usage: {{ github_tar('eza', 'https://github.com/.../eza_x86_64.tar.gz') }}
#}
{%- macro github_tar(name, url, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        TMPDIR=$(mktemp -d)
        curl -fsSL {{ url }} -o "$TMPDIR/archive.tar.gz"
        tar -xzf "$TMPDIR/archive.tar.gz" -C "$TMPDIR"
        find "$TMPDIR" -name '{{ name }}' -type f -exec install -m755 {} ~/.local/bin/{{ name }} \;
        rm -rf "$TMPDIR"
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ home }}/.local/bin/{{ name }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# Download latest GitHub release asset to ~/.local/bin/.
   Fetches TAG via GitHub API, supports direct binary or tar.gz.
   Usage: {{ github_release('sops', 'getsops/sops', 'sops-${TAG}.linux.amd64') }}
          {{ github_release('rmpc', 'mierak/rmpc', 'rmpc-${TAG}-x86_64.tar.gz', format='tar.gz') }}
          {{ github_release('sing-box', 'SagerNet/sing-box', 'sing-box-${VER}.tar.gz', format='tar.gz', strip_v=True) }}
#}
{%- macro github_release(name, repo, asset, bin=None, format='bin', strip_v=False, user='neg', home='/home/neg') -%}
{%- set target = bin or name -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        TAG=$(curl -fsSIL -o /dev/null -w '%{url_effective}' https://github.com/{{ repo }}/releases/latest | grep -oP '[^/]+$')
{%- if strip_v %}
        VER=${TAG#v}
{%- endif %}
{%- if format == 'bin' %}
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o ~/.local/bin/{{ target }}
        chmod +x ~/.local/bin/{{ target }}
{%- elif format == 'tar.gz' %}
        TMPDIR=$(mktemp -d)
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o "$TMPDIR/archive.tar.gz"
        tar -xzf "$TMPDIR/archive.tar.gz" -C "$TMPDIR"
        find "$TMPDIR" -name '{{ target }}' -type f -exec install -m755 {} ~/.local/bin/{{ target }} \;
        rm -rf "$TMPDIR"
{%- endif %}
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ home }}/.local/bin/{{ target }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# Download latest GitHub release asset to /usr/local/bin/ (system-level).
   Like github_release but runs as root, no runas. Supports zip and tar.gz.
   src_bin: filename of the binary inside the archive (default: name).
   Usage: {{ github_release_system('loki', 'grafana/loki', 'loki-linux-amd64.zip', src_bin='loki-linux-amd64') }}
          {{ github_release_system('adguardhome', 'AdguardTeam/AdGuardHome', 'AdGuardHome_linux_amd64.tar.gz', src_bin='AdGuardHome', format='tar.gz') }}
#}
{%- macro github_release_system(name, repo, asset, src_bin=None, format='zip', dest='/usr/local/bin') -%}
{%- set source_bin = src_bin or name -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        TAG=$(curl -fsSIL -o /dev/null -w '%{url_effective}' https://github.com/{{ repo }}/releases/latest | grep -oP '[^/]+$')
{%- if format == 'zip' %}
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o /tmp/{{ name }}.zip
        unzip -o /tmp/{{ name }}.zip -d /tmp
        install -m 0755 /tmp/{{ source_bin }} {{ dest }}/{{ name }}
        rm -f /tmp/{{ name }}.zip /tmp/{{ source_bin }}
{%- elif format == 'tar.gz' %}
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o /tmp/{{ name }}.tar.gz
        tar -xzf /tmp/{{ name }}.tar.gz -C /tmp
        find /tmp -maxdepth 3 -name '{{ source_bin }}' -type f -exec install -m 0755 {} {{ dest }}/{{ name }} \;
        rm -rf /tmp/{{ name }}.tar.gz /tmp/{{ source_bin }}*
{%- endif %}
    - shell: /bin/bash
    - creates: {{ dest }}/{{ name }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# pipx install (PEP 668 compatible).
   Usage: {{ pip_pkg('httpstat') }}
          {{ pip_pkg('neovim_python_deps', pkg='neovim-remote', bin='nvr') }}
#}
{%- macro pip_pkg(name, pkg=None, bin=None, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: pipx install {{ pkg or name }}
    - runas: {{ user }}
    - creates: {{ home }}/.local/bin/{{ bin or name }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# cargo install (crates.io or git).
   Usage: {{ cargo_pkg('handlr', pkg='handlr-regex') }}
          {{ cargo_pkg('agg', git='https://github.com/asciinema/agg') }}
          {{ cargo_pkg('pzip', bin='pz') }}
#}
{%- macro cargo_pkg(name, pkg=None, bin=None, git=None, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: cargo install {{ '--git ' ~ git if git else pkg or name }}
    - runas: {{ user }}
    - creates: {{ home }}/.local/share/cargo/bin/{{ bin or name }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# npm install -g (global npm package).
   Usage: {{ npm_pkg('openclaw') }}
          {{ npm_pkg('prettier', bin='prettier') }}
#}
{%- macro npm_pkg(name, pkg=None, bin=None, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: npm install -g {{ pkg or name }}
    - runas: {{ user }}
    - creates: {{ home }}/.local/bin/{{ bin or name }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# Install packages via pacman (CachyOS/Arch).
   check defaults to first package. requires is an optional list of requisites.
   Usage: {{ pacman_install('unbound', 'unbound') }}
          {{ pacman_install('jellyfin', 'jellyfin-server jellyfin-web') }}
#}
{%- macro pacman_install(name, pkgs, check=None, requires=None) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: pacman -S --noconfirm --needed {{ pkgs }}
    - unless: |
        C=/var/cache/salt/pacman_installed.txt
        [ -f "$C" ] || pacman -Qq > "$C"
        grep -qx '{{ check or pkgs.split()[0] }}' "$C"
{%- if requires %}
    - require:
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endmacro -%}

{# Build and install a package from a local PKGBUILD via file.recurse + makepkg + pacman -U.
   source: salt:// path to PKGBUILD directory. check: package name for idempotency guard (default: name).
   Usage: {{ pkgbuild_install('raise', 'salt://build/pkgbuilds/raise', user='neg') }}
          {{ pkgbuild_install('iosevka-neg-fonts', 'salt://build/pkgbuilds/iosevka-neg-fonts', user='neg', timeout=7200) }}
#}
{%- macro pkgbuild_install(name, source, user='neg', build_base='/tmp/pkgbuild', timeout=600, check=None) -%}
{%- set safe = name | replace('-', '_') -%}
{{ safe }}_pkgbuild:
  file.recurse:
    - name: {{ build_base }}/{{ name }}
    - source: {{ source }}
    - makedirs: True
    - user: {{ user }}
    - group: {{ user }}

build_{{ safe }}:
  cmd.run:
    - name: |
        set -eo pipefail
        su - {{ user }} -c 'cd {{ build_base }}/{{ name }} && makepkg -sf --noconfirm'
        pacman -U --noconfirm --needed {{ build_base }}/{{ name }}/*.pkg.tar.zst
        rm -rf {{ build_base }}/{{ name }}
    - shell: /bin/bash
    - timeout: {{ timeout }}
    - unless: |
        C=/var/cache/salt/pacman_installed.txt
        [ -f "$C" ] || pacman -Qq > "$C"
        grep -qx '{{ check or name }}' "$C"
    - require:
      - file: {{ safe }}_pkgbuild
{%- endmacro -%}

{# Create system daemon user + data directory.
   Consolidates: user.present (system user, nologin shell) + file.directory (homedir/datadir with ownership).
   shell defaults to /usr/sbin/nologin. createhome defaults to False (createhome by file.directory instead).
   Usage: {{ system_daemon_user('loki', '/var/lib/loki') }}
          {{ system_daemon_user('adguardhome', '/var/lib/adguardhome') }}
          {{ system_daemon_user('bitcoind', '/var/lib/bitcoind', requires=['cmd: install_bitcoind']) }}
#}
{%- macro system_daemon_user(name, home_dir, shell='/usr/sbin/nologin', requires=None) -%}
{{ name }}_user:
  user.present:
    - name: {{ name }}
    - system: True
    - shell: {{ shell }}
    - home: {{ home_dir }}
    - createhome: False

{{ name }}_data_dir:
  file.directory:
    - name: {{ home_dir }}
    - user: {{ name }}
    - group: {{ name }}
    - makedirs: True
    - require:
      - user: {{ name }}_user
{%- if requires %}
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endmacro -%}

{# Wrap cmd.run with standardized error handling. Provides shell helper functions for
   consistent error messages, timestamped status output, and clean failure reporting.
   Useful for complex multi-step operations (installs, builds, configuration).
   Usage:
   {% call run_with_error_context('install_foo', requires=['cmd: install_bar']) %}
   source /build/salt/error-helpers.sh
   step "Downloading foo"
   curl -fsSL https://example.com/foo -o /tmp/foo
   run_step "Installing foo" install -m755 /tmp/foo ~/.local/bin/
   success "Foo installed"
   {% endcall %}
#}
{%- macro run_with_error_context(state_id, requires=None, creates=None, shell='/bin/bash') -%}
{{ state_id }}:
  cmd.run:
    - name: |
        set -uo pipefail
        step() { printf "[%s] %s\n" "$(date +'%H:%M:%S')" "$*"; }
        success() { printf "[  âœ“  ] %s\n" "$*"; }
        trap 'echo "[EXIT] Cleanup on exit (code: $?)" >&2' EXIT
        {{ caller() | indent(8) }}
    - shell: {{ shell }}
{% if creates %}
    - creates: {{ creates }}
{% endif %}
{% if requires %}
    - require:
{% for req in requires %}
      - {{ req }}
{% endfor %}
{% endif %}

{%- endmacro -%}

{# Download and extract tar.gz/tar.xz archive, move binary(ies) to ~/.local/bin/.
   Supports: TAG fetching, nested directories, multiple binaries, optional chmod.
   archive_ext: tar.gz (default) | tar.xz. fetch_tag: True (default False) to fetch latest ${TAG} from GitHub API.
   binary_pattern: path pattern for finding binaries after extraction (e.g., "nu-*/nu" or "streaming_extractor_music").
   binaries: optional list of binary names to move. If None, uses basename of binary_pattern.
   chmod: True (default False) to chmod +x extracted binaries.
   bin: output binary name (default: basename of binary_pattern). Use when archive name differs from desired binary name.
   dest: extract directly to this directory (skips find+move, for non-binary archives).
   strip_components: --strip-components=N for tar (used with dest).
   creates: override creates guard (default: ~/.local/bin/<binary> or dest).
   Usage: {{ curl_extract_tar('nushell', 'https://github.com/nushell/nushell/releases/latest/download/nu-${TAG}-x86_64-unknown-linux-musl.tar.gz', 'nu-*/nu', fetch_tag=True) }}
          {{ curl_extract_tar('hyprevents', 'https://github.com/vilari-mickopf/hyprevents/archive/refs/heads/master.tar.gz', 'hyprevents/hyprevents', binaries=['hyprevents', 'event_handler', 'event_loader']) }}
          {{ curl_extract_tar('blesh', 'https://github.com/.../ble-nightly.tar.xz', archive_ext='tar.xz', dest='~/.local/share', strip_components=1, creates=home ~ '/.local/share/ble.sh') }}
          {{ curl_extract_tar('nyxt', '...', 'Nyxt-x86_64.AppImage', bin='nyxt', chmod=True) }}
#}
{%- macro curl_extract_tar(name, url, binary_pattern=None, archive_ext='tar.gz', fetch_tag=False, binaries=None, bin=None, chmod=False, dest=None, strip_components=None, creates=None, bin_dest=None, user='neg', home='/home/neg') -%}
{%- set ext_flag = 'J' if archive_ext == 'tar.xz' else 'z' -%}
{%- set target_dir = bin_dest or '~/.local/bin' -%}
{%- if fetch_tag %}
{%- if '/api.github.com/repos/' in url %}
{%- set repo_path = url.split('/repos/')[1].split('/')[0:2] | join('/') %}
{%- else %}
{%- set repo_path = url.split('github.com/')[1].split('/')[0:2] | join('/') %}
{%- endif %}
{%- endif %}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
{%- if fetch_tag %}
        TAG=$(curl -fsSIL -o /dev/null -w '%{url_effective}' https://github.com/{{ repo_path }}/releases/latest | grep -oP '[^/]+$')
{%- endif %}
        curl -fsSL "{{ url }}" -o /tmp/{{ name }}.{{ archive_ext }}
{%- if dest %}
        mkdir -p {{ dest }}
        tar -x{{ ext_flag }}f /tmp/{{ name }}.{{ archive_ext }} -C {{ dest }}{{ ' --strip-components=' ~ strip_components if strip_components }}
{%- else %}
        tar -x{{ ext_flag }}f /tmp/{{ name }}.{{ archive_ext }} -C /tmp
{%- if binaries %}
{% for b in binaries %}
        install -m 0755 /tmp/{{ binary_pattern.replace('*', b) if '*' in binary_pattern else binary_pattern }}/{{ b }} {{ target_dir }}/ 2>/dev/null || install -m 0755 /tmp/{{ binary_pattern.rsplit('/', 1)[0] }}/{{ b }} {{ target_dir }}/
{%- endfor %}
{%- else %}
        find /tmp -maxdepth 3 -path "*{{ binary_pattern }}*" -type f ! -name "*.tar*" -exec install -m755 {} {{ target_dir }}/{{ bin or binary_pattern.rsplit('/', 1)[-1] }} \;
{%- endif %}
{%- if chmod %}
{%- for b in (binaries or [bin or binary_pattern.rsplit('/', 1)[-1]]) %}
        chmod +x {{ target_dir }}/{{ b }}
{%- endfor %}
{%- endif %}
{%- endif %}
        rm -rf /tmp/{{ name }}.{{ archive_ext }} /tmp/{{ name }}-* /tmp/{{ name }}
{%- if user %}
    - runas: {{ user }}
{%- endif %}
    - shell: /bin/bash
    - creates: {{ creates or ((dest | replace('~', home)) if dest else (bin_dest or home ~ '/.local/bin') ~ '/' ~ (bin or (binaries[0] if binaries else binary_pattern.rsplit('/', 1)[-1]))) }}
    - retry:
        attempts: 3
        interval: 10

{%- endmacro -%}

{# Download and extract ZIP archive, move binary(ies) to ~/.local/bin/.
   Supports: nested directories, multiple binaries, optional chmod.
   binary_path: path pattern relative to extraction dir (e.g., "yazi-x86_64-unknown-linux-musl/yazi").
   binaries: optional list of binaries to move. If None, uses last part of binary_path.
   chmod: True (default False) to chmod +x extracted binaries.
   dest: extract directly to this directory (skips find+move, for app bundles).
   symlink: create symlink from dest/<symlink> to ~/.local/bin/<name> after extraction.
   creates: override creates guard (default: ~/.local/bin/<binary> or dest).
   Usage: {{ curl_extract_zip('xray', 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip', 'xray/xray', chmod=True) }}
          {{ curl_extract_zip('yazi', 'https://github.com/sxyazi/yazi/releases/latest/download/yazi-x86_64-unknown-linux-musl.zip', 'yazi-x86_64-unknown-linux-musl', binaries=['yazi', 'ya']) }}
          {{ curl_extract_zip('roomeqwizard', '...', dest='~/.local/opt/roomeqwizard') }}
          {{ curl_extract_zip('throne', '...', dest='~/.local/opt/throne', symlink='Throne') }}
#}
{%- macro curl_extract_zip(name, url, binary_path=None, binaries=None, chmod=False, dest=None, symlink=None, creates=None, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        curl -fsSL "{{ url }}" -o /tmp/{{ name }}.zip
{%- if dest %}
        mkdir -p {{ dest }}
        unzip -o /tmp/{{ name }}.zip -d {{ dest }}
{%- if symlink %}
        ln -sf {{ dest }}/{{ symlink }} ~/.local/bin/{{ name }}
{%- endif %}
{%- else %}
        unzip -o /tmp/{{ name }}.zip -d /tmp/{{ name }}_extracted
{%- if binaries %}
{%- for bin in binaries %}
        mv /tmp/{{ name }}_extracted/{{ binary_path }}/{{ bin }} ~/.local/bin/
{%- endfor %}
{%- else %}
        mv /tmp/{{ name }}_extracted/{{ binary_path }} ~/.local/bin/{{ binary_path.rsplit('/', 1)[-1] }}
{%- endif %}
{%- if chmod %}
{%- for bin in (binaries or [binary_path.rsplit('/', 1)[-1]]) %}
        chmod +x ~/.local/bin/{{ bin }}
{%- endfor %}
{%- endif %}
{%- endif %}
        rm -rf /tmp/{{ name }}.zip /tmp/{{ name }}_extracted
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ creates or ((dest | replace('~', home)) if dest else home ~ '/.local/bin/' ~ (binaries[0] if binaries else binary_path.rsplit('/', 1)[-1])) }}
    - retry:
        attempts: 3
        interval: 10


{%- endmacro -%}

{# Download Firefox/Floorp extension .xpi from addons.mozilla.org.
   ext: dict with 'id' (extension GUID) and 'slug' (AMO slug).
   profile: path to browser profile directory.
   Usage: {{ firefox_extension(ext, floorp_profile, require='floorp_extensions_dir') }}
#}
{%- macro firefox_extension(ext, profile, require=None, user='neg') -%}
floorp_ext_{{ ext.slug | replace('-', '_') }}:
  cmd.run:
    - name: curl -fsSL -o '{{ profile }}/extensions/{{ ext.id }}.xpi' 'https://addons.mozilla.org/firefox/downloads/latest/{{ ext.slug }}/latest.xpi'
    - creates: {{ profile }}/extensions/{{ ext.id }}.xpi
    - runas: {{ user }}
{%- if require %}
    - require:
      - file: {{ require }}
{%- endif %}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# Deploy inline systemd user unit file (~/.config/systemd/user/).
   Callable macro: unit content goes inside {% call %} block.
   Usage:
   {% call user_service('mbsync_gmail_service', 'mbsync-gmail.service', user=user, home=home) %}
   [Unit]
   Description=Mailbox synchronization (Gmail)
   [Service]
   Type=oneshot
   ExecStart=/usr/bin/mbsync -c %h/.config/mbsync/mbsyncrc gmail
   [Install]
   WantedBy=default.target
   {% endcall %}
#}
{%- macro user_service(name, filename, user='neg', home='/home/neg') -%}
{{ name }}:
  file.managed:
    - name: {{ home }}/.config/systemd/user/{{ filename }}
    - user: {{ user }}
    - group: {{ user }}
    - mode: '0644'
    - makedirs: True
    - contents: |
{{ caller() | trim | indent(8, first=True) }}
{%- endmacro -%}

{# Download and install a font from a ZIP archive to ~/.local/share/fonts/<subdir>.
   Creates the target directory, downloads/unzips, runs fc-cache, cleans up.
   Usage: {{ download_font_zip('sf_pro_display', 'https://font.download/dl/font/sf-pro-display.zip', 'SFProDisplay') }}
          {{ download_font_zip('anurati', 'https://font.download/dl/font/anurati.zip', 'Anurati') }}
#}
{%- macro download_font_zip(name, url, subdir, user='neg', home='/home/neg') -%}
{%- set fonts_dir = home ~ '/.local/share/fonts' -%}
{{ fonts_dir }}/{{ subdir }}:
  file.directory:
    - user: {{ user }}
    - group: {{ user }}
    - makedirs: True

install_{{ name }}:
  cmd.run:
    - name: |
        set -eo pipefail
        curl -fsSL '{{ url }}' -o /tmp/{{ name }}.zip
        unzip -o /tmp/{{ name }}.zip -d {{ fonts_dir }}/{{ subdir }}
        fc-cache -f {{ fonts_dir }}/{{ subdir }}
        rm -f /tmp/{{ name }}.zip
        touch {{ fonts_dir }}/{{ subdir }}/.salt-installed
    - runas: {{ user }}
    - shell: /bin/bash
    - unless: |
        S="{{ fonts_dir }}/{{ subdir }}/.salt-installed"
        [ -f "$S" ] && exit 0
        find {{ fonts_dir }}/{{ subdir }} -maxdepth 1 \( -name '*.otf' -o -name '*.ttf' \) -print -quit 2>/dev/null | grep -q .
    - retry:
        attempts: 3
        interval: 10
    - require:
      - file: {{ fonts_dir }}/{{ subdir }}
{%- endmacro -%}

{# Git clone a repo to /tmp, copy selected items to dest, clean up.
   items: list of paths relative to repo root to cp -r (e.g., ['Flight-Dark-GTK', 'Flight-light-GTK'] or ['*/']).
          If omitted, clones directly to dest (repo itself IS the install).
   creates: idempotency guard (defaults to dest).
   Usage: {{ git_clone_deploy('flight-gtk', 'https://github.com/neg-serg/Flight-Plasma-Themes.git', '~/.local/share/themes', ['Flight-Dark-GTK', 'Flight-light-GTK']) }}
          {{ git_clone_deploy('zi', 'https://github.com/z-shell/zi.git', '~/.config/zi/bin', creates=home ~ '/.config/zi/bin/zi.zsh') }}
#}
{%- macro git_clone_deploy(name, repo, dest, items=None, creates=None, user='neg', home='/home/neg') -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
{%- if items %}
        git clone --depth=1 {{ repo }} /tmp/{{ name }}
        mkdir -p {{ dest }}
{%- for item in items %}
        cp -r /tmp/{{ name }}/{{ item }} {{ dest }}/
{%- endfor %}
        rm -rf /tmp/{{ name }}
{%- else %}
        git clone --depth=1 {{ repo }} {{ dest }}
{%- endif %}
    - runas: {{ user }}
    - shell: /bin/bash
    - creates: {{ creates or (dest | replace('~', home)) }}
    - retry:
        attempts: 3
        interval: 10
{%- endmacro -%}

{# Deploy systemd unit file + manage service (file + daemon-reload + enable/disable + optional running).
   unit_type: 'service' (default) | 'timer' | 'socket' | etc.
   running: True (default False) to add service.running with watch for auto-restart.
   enabled: True (default) = service.enabled; False = service.disabled; None = skip enable/disable.
   requires: optional list of state requisites (includes daemon-reload as base requirement).
   template: 'jinja' (default None) to render the unit file as a Jinja template.
   context: dict of template variables (default None), used with template='jinja'.
   onlyif: guard for service.enabled (default None), e.g. 'command -v ollama'.
   companion: optional second unit source for service+timer pairs (daemon-reload watches both).
   Usage: {{ service_with_unit('loki', 'salt://units/loki.service', requires=['cmd: install_loki', 'file: loki_config']) }}
          {{ service_with_unit('ollama', 'salt://units/ollama.service', template='jinja', context={'user': user, 'home': home}, onlyif='command -v ollama') }}
          {{ service_with_unit('xray', 'salt://units/xray.service', enabled=False) }}
          {{ service_with_unit('duckdns-update', 'salt://units/duckdns-update.timer', unit_type='timer', enabled=False, companion='salt://units/duckdns-update.service') }}
#}
{%- macro service_with_unit(name, source, unit_type='service', running=False, enabled=True, requires=None, template=None, context=None, onlyif=None, companion=None) -%}
{{ name }}_service:
  file.managed:
    - name: /etc/systemd/system/{{ name }}.{{ unit_type }}
    - mode: '0644'
    - source: {{ source }}
{%- if template %}
    - template: {{ template }}
{%- endif %}
{%- if context %}
    - context:
{%- for key, val in context.items() %}
        {{ key }}: {{ val }}
{%- endfor %}
{%- endif %}
{%- if companion %}

{{ name }}_companion:
  file.managed:
    - name: /etc/systemd/system/{{ name }}.{{ 'service' if unit_type != 'service' else 'timer' }}
    - mode: '0644'
    - source: {{ companion }}
{%- if template %}
    - template: {{ template }}
{%- endif %}
{%- if context %}
    - context:
{%- for key, val in context.items() %}
        {{ key }}: {{ val }}
{%- endfor %}
{%- endif %}
{%- endif %}

{{ name }}_daemon_reload:
  cmd.run:
    - name: systemctl daemon-reload
    - onchanges:
      - file: {{ name }}_service
{%- if companion %}
      - file: {{ name }}_companion
{%- endif %}
{%- if enabled is not none %}

{{ name }}_{{ 'enabled' if enabled else 'disabled' }}:
  service.{{ 'enabled' if enabled else 'disabled' }}:
    - name: {{ name }}
{%- if onlyif and enabled %}
    - onlyif: {{ onlyif }}
{%- endif %}
    - require:
      - cmd: {{ name }}_daemon_reload
{%- if requires %}
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endif %}
{%- if running %}

{{ name }}_running:
  service.running:
    - name: {{ name }}
    - watch:
      - file: {{ name }}_service
    - require:
      - service: {{ name }}_enabled
{%- endif %}
{%- endmacro -%}
