{# Reusable Salt state macros for common patterns #}

{# Trigger systemd daemon-reload when listed states change.
   Usage: {{ daemon_reload('unbound', ['cmd: install_unbound', 'file: unbound_override']) }}
#}
{%- macro daemon_reload(name, onchanges) -%}
{{ name }}_daemon_reload:
  cmd.run:
    - name: systemctl daemon-reload
    - onchanges:
{%- for item in onchanges %}
      - {{ item }}
{%- endfor %}
{%- endmacro -%}

{# Download binary directly to ~/.local/bin/ and chmod +x.
   Usage: {{ curl_bin('aliae', 'https://github.com/.../aliae-linux-amd64') }}
          {{ curl_bin('xdg-ninja', 'https://github.com/.../xdgnj') }}
#}
{%- macro curl_bin(name, url) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: curl -fsSL {{ url }} -o ~/.local/bin/{{ name }} && chmod +x ~/.local/bin/{{ name }}
    - runas: neg
    - creates: /home/neg/.local/bin/{{ name }}
{%- endmacro -%}

{# Download tar.gz, extract single binary to ~/.local/bin/.
   Usage: {{ github_tar('eza', 'https://github.com/.../eza_x86_64.tar.gz') }}
#}
{%- macro github_tar(name, url) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        curl -fsSL {{ url }} -o /tmp/{{ name }}.tar.gz
        tar -xzf /tmp/{{ name }}.tar.gz -C /tmp {{ name }}
        install -m755 /tmp/{{ name }} ~/.local/bin/{{ name }}
        rm -f /tmp/{{ name }}.tar.gz /tmp/{{ name }}
    - runas: neg
    - shell: /bin/bash
    - creates: /home/neg/.local/bin/{{ name }}
{%- endmacro -%}

{# Download latest GitHub release asset to ~/.local/bin/.
   Fetches TAG via GitHub API, supports direct binary or tar.gz.
   Usage: {{ github_release('sops', 'getsops/sops', 'sops-${TAG}.linux.amd64') }}
          {{ github_release('rmpc', 'mierak/rmpc', 'rmpc-${TAG}-x86_64.tar.gz', format='tar.gz') }}
          {{ github_release('sing-box', 'SagerNet/sing-box', 'sing-box-${VER}.tar.gz', format='tar.gz', strip_v=True) }}
#}
{%- macro github_release(name, repo, asset, bin=None, format='bin', strip_v=False) -%}
{%- set target = bin or name -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        TAG=$(curl -fsSL https://api.github.com/repos/{{ repo }}/releases/latest | jq -r .tag_name)
{%- if strip_v %}
        VER=${TAG#v}
{%- endif %}
{%- if format == 'bin' %}
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o ~/.local/bin/{{ target }}
        chmod +x ~/.local/bin/{{ target }}
{%- elif format == 'tar.gz' %}
        TMPDIR=$(mktemp -d)
        curl -fsSL "https://github.com/{{ repo }}/releases/download/${TAG}/{{ asset }}" -o "$TMPDIR/archive.tar.gz"
        tar -xzf "$TMPDIR/archive.tar.gz" -C "$TMPDIR"
        find "$TMPDIR" -name '{{ target }}' -type f -exec install -m755 {} ~/.local/bin/{{ target }} \;
        rm -rf "$TMPDIR"
{%- endif %}
    - runas: neg
    - shell: /bin/bash
    - creates: /home/neg/.local/bin/{{ target }}
{%- endmacro -%}

{# pip install --user.
   Usage: {{ pip_pkg('httpstat') }}
          {{ pip_pkg('neovim_deps', pkg='pynvim neovim-remote', bin='nvr') }}
#}
{%- macro pip_pkg(name, pkg=None, bin=None) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: pip install --user {{ pkg or name }}
    - runas: neg
    - creates: /home/neg/.local/bin/{{ bin or name }}
{%- endmacro -%}

{# cargo install (crates.io or git).
   Usage: {{ cargo_pkg('handlr', pkg='handlr-regex') }}
          {{ cargo_pkg('agg', git='https://github.com/asciinema/agg') }}
          {{ cargo_pkg('pzip', bin='pz') }}
#}
{%- macro cargo_pkg(name, pkg=None, bin=None, git=None) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: cargo install {{ '--git ' ~ git if git else pkg or name }}
    - runas: neg
    - creates: /home/neg/.local/share/cargo/bin/{{ bin or name }}
{%- endmacro -%}

{# Install a custom SELinux policy module (compile .te → .pp → semodule -i).
   Uses caller() block for multi-line policy content.
   Usage:
     {% call selinux_policy('ollama_selinux_network', 'ollama-network') %}
     module ollama-network 1.0;
     require { type init_t; type http_port_t; class tcp_socket name_connect; }
     allow init_t http_port_t:tcp_socket name_connect;
     {% endcall %}
#}
{%- macro selinux_policy(state_id, module) -%}
{{ state_id }}:
  cmd.run:
    - name: |
        TMP=$(mktemp -d)
        cat > "$TMP/{{ module }}.te" << 'POLICY'
{{ caller() | trim | indent(8, first=true) }}
        POLICY
        checkmodule -M -m -o "$TMP/{{ module }}.mod" "$TMP/{{ module }}.te"
        semodule_package -o "$TMP/{{ module }}.pp" -m "$TMP/{{ module }}.mod"
        semodule -i "$TMP/{{ module }}.pp"
        rm -rf "$TMP"
    - unless: semodule -l | grep -q '^{{ module }}'
{%- endmacro -%}

{# Set SELinux file context on a path (semanage fcontext + restorecon).
   selinux_path is the path for semanage fcontext.
   real_path is the actual filesystem path for restorecon.
   check_path overrides what ls -Zd checks (defaults to real_path).
   Usage: {{ selinux_fcontext('steam_selinux', '/mnt/zero/games', '/mnt/zero/games', 'user_home_t') }}
          {{ selinux_fcontext('ollama_ctx', '/mnt/one/ollama', '/mnt/one/ollama', 'var_lib_t', requires=['file: ollama_models_dir']) }}
#}
{%- macro selinux_fcontext(name, selinux_path, real_path, selinux_type, check_path=None, requires=None) -%}
{{ name }}:
  cmd.run:
    - name: |
        semanage fcontext -a -t {{ selinux_type }} "{{ selinux_path }}(/.*)?" 2>/dev/null || \
        semanage fcontext -m -t {{ selinux_type }} "{{ selinux_path }}(/.*)?"
        restorecon -Rv {{ real_path }}
    - unless: ls -Zd {{ check_path or real_path }} 2>/dev/null | grep -q {{ selinux_type }}
{%- if requires %}
    - require:
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endmacro -%}

{# rpm-ostree install with --apply-live (for conditional/feature-gated packages).
   check defaults to first package. requires is an optional list of requisites.
   Usage: {{ ostree_install('unbound', 'unbound') }}
          {{ ostree_install('jellyfin', 'jellyfin-server jellyfin-web', requires=['file: jellyfin_repo']) }}
#}
{%- macro ostree_install(name, pkgs, check=None, requires=None) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: rpm-ostree install --idempotent --apply-live {{ pkgs }}
    - unless: rpm -q {{ check or pkgs.split()[0] }}
{%- if requires %}
    - require:
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endmacro -%}

{# Create system daemon user + data directory.
   Consolidates: user.present (system user, nologin shell) + file.directory (homedir/datadir with ownership).
   shell defaults to /usr/sbin/nologin. createhome defaults to False (createhome by file.directory instead).
   Usage: {{ system_daemon_user('loki', '/var/lib/loki') }}
          {{ system_daemon_user('adguardhome', '/var/lib/adguardhome') }}
          {{ system_daemon_user('bitcoind', '/var/lib/bitcoind', requires=['cmd: install_bitcoind']) }}
#}
{%- macro system_daemon_user(name, home_dir, shell='/usr/sbin/nologin', requires=None) -%}
{{ name }}_user:
  user.present:
    - name: {{ name }}
    - system: True
    - shell: {{ shell }}
    - home: {{ home_dir }}
    - createhome: False

{{ name }}_data_dir:
  file.directory:
    - name: {{ home_dir }}
    - user: {{ name }}
    - group: {{ name }}
    - makedirs: True
    - require:
      - user: {{ name }}_user
{%- if requires %}
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}
{%- endmacro -%}

{# Wrap cmd.run with standardized error handling. Provides shell helper functions for
   consistent error messages, timestamped status output, and clean failure reporting.
   Useful for complex multi-step operations (installs, builds, configuration).
   Usage:
   {% call run_with_error_context('install_foo', requires=['cmd: install_bar']) %}
   source /build/salt/error-helpers.sh
   step "Downloading foo"
   curl -fsSL https://example.com/foo -o /tmp/foo
   run_step "Installing foo" install -m755 /tmp/foo ~/.local/bin/
   success "Foo installed"
   {% endcall %}
#}
{%- macro run_with_error_context(state_id, requires=None, creates=None, shell='/bin/bash') -%}
{{ state_id }}:
  cmd.run:
    - name: |
        set -uo pipefail
        source /build/salt/error-helpers.sh
        trap 'echo "[EXIT] Cleanup on exit (code: $?)" >&2' EXIT
        {{ caller() | indent(8) }}
    - shell: {{ shell }}
{% if creates %}
    - creates: {{ creates }}
{% endif %}
{% if requires %}
    - require:
{% for req in requires %}
      - {{ req }}
{% endfor %}
{% endif %}

{%- endmacro -%}

{# Download and extract tar.gz/tar.xz archive, move binary(ies) to ~/.local/bin/.
   Supports: TAG fetching, nested directories, multiple binaries, optional chmod.
   archive_ext: tar.gz (default) | tar.xz. fetch_tag: True (default False) to fetch latest ${TAG} from GitHub API.
   binary_pattern: path pattern for finding binaries after extraction (e.g., "nu-*/nu" or "streaming_extractor_music").
   binaries: optional list of binary names to move. If None, uses basename of binary_pattern.
   chmod: True (default False) to chmod +x extracted binaries.
   Usage: {{ curl_extract_tar('nushell', 'https://github.com/nushell/nushell/releases/latest/download/nu-${TAG}-x86_64-unknown-linux-musl.tar.gz', 'nu-*/nu', fetch_tag=True) }}
          {{ curl_extract_tar('hyprevents', 'https://github.com/vilari-mickopf/hyprevents/archive/refs/heads/master.tar.gz', 'hyprevents/hyprevents', binaries=['hyprevents', 'event_handler', 'event_loader']) }}
#}
{%- macro curl_extract_tar(name, url, binary_pattern, archive_ext='tar.gz', fetch_tag=False, binaries=None, chmod=False) -%}
{%- set ext_flag = 'J' if archive_ext == 'tar.xz' else 'z' -%}
{%- if fetch_tag %}
{%- if '/api.github.com/repos/' in url %}
{%- set repo_path = url.split('/repos/')[1].split('/')[0:2] | join('/') %}
{%- else %}
{%- set repo_path = url.split('github.com/')[1].split('/')[0:2] | join('/') %}
{%- endif %}
{%- endif %}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
{%- if fetch_tag %}
        TAG=$(curl -fsSL https://api.github.com/repos/{{ repo_path }}/releases/latest | jq -r .tag_name)
{%- endif %}
        curl -fsSL "{{ url }}" -o /tmp/{{ name }}.{{ archive_ext }}
        tar -x{{ ext_flag }}f /tmp/{{ name }}.{{ archive_ext }} -C /tmp
{%- if binaries %}
{% for bin in binaries %}
        mv /tmp/{{ binary_pattern.replace('*', bin) if '*' in binary_pattern else binary_pattern }}/{{ bin }} ~/.local/bin/ 2>/dev/null || mv /tmp/{{ binary_pattern.rsplit('/', 1)[0] }}/{{ bin }} ~/.local/bin/
{%- endfor %}
{%- else %}
        find /tmp -maxdepth 3 -path "*{{ binary_pattern }}*" -type f ! -name "*.tar*" -exec install -m755 {} ~/.local/bin/{{ binary_pattern.rsplit('/', 1)[-1] }} \;
{%- endif %}
{%- if chmod %}
        chmod +x ~/.local/bin/{{ binaries[0] if binaries else binary_pattern.rsplit('/', 1)[-1] }}
{%- endif %}
        rm -rf /tmp/{{ name }}.{{ archive_ext }} /tmp/{{ name }}-* /tmp/{{ name }}
    - runas: neg
    - shell: /bin/bash
    - creates: /home/neg/.local/bin/{{ binaries[0] if binaries else binary_pattern.rsplit('/', 1)[-1] }}

{%- endmacro -%}

{# Download and extract ZIP archive, move binary(ies) to ~/.local/bin/.
   Supports: nested directories, multiple binaries, optional chmod.
   binary_path: path pattern relative to extraction dir (e.g., "yazi-x86_64-unknown-linux-musl/yazi").
   binaries: optional list of binaries to move. If None, uses last part of binary_path.
   chmod: True (default False) to chmod +x extracted binaries.
   Usage: {{ curl_extract_zip('xray', 'https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip', 'xray/xray', chmod=True) }}
          {{ curl_extract_zip('yazi', 'https://github.com/sxyazi/yazi/releases/latest/download/yazi-x86_64-unknown-linux-musl.zip', 'yazi-x86_64-unknown-linux-musl', binaries=['yazi', 'ya']) }}
#}
{%- macro curl_extract_zip(name, url, binary_path, binaries=None, chmod=False) -%}
install_{{ name | replace('-', '_') }}:
  cmd.run:
    - name: |
        set -eo pipefail
        curl -fsSL "{{ url }}" -o /tmp/{{ name }}.zip
        unzip -o /tmp/{{ name }}.zip -d /tmp/{{ name }}_extracted
{%- if binaries %}
{%- for bin in binaries %}
        mv /tmp/{{ name }}_extracted/{{ binary_path }}/{{ bin }} ~/.local/bin/
{%- endfor %}
{%- else %}
        mv /tmp/{{ name }}_extracted/{{ binary_path }} ~/.local/bin/{{ binary_path.rsplit('/', 1)[-1] }}
{%- endif %}
{%- if chmod %}
        chmod +x ~/.local/bin/{{ binaries[0] if binaries else binary_path.rsplit('/', 1)[-1] }}
{%- endif %}
        rm -rf /tmp/{{ name }}.zip /tmp/{{ name }}_extracted
    - runas: neg
    - shell: /bin/bash
    - creates: /home/neg/.local/bin/{{ binaries[0] if binaries else binary_path.rsplit('/', 1)[-1] }}


{%- endmacro -%}

{# Deploy systemd unit file + enable service (file + daemon-reload + service.enabled + optional service.running).
   unit_type: 'service' (default) | 'timer' | 'socket' | etc.
   running: True (default False) to add service.running after enabled for auto-start behavior.
   requires: optional list of state requisites (includes daemon-reload as base requirement).
   Usage: {{ service_with_unit('loki', 'salt://units/loki.service', requires=['cmd: install_loki', 'file: loki_config']) }}
          {{ service_with_unit('fancontrol', 'salt://units/fancontrol.service', running=True, requires=['file: fancontrol_service', 'cmd: install_fancontrol']) }}
#}
{%- macro service_with_unit(name, source, unit_type='service', running=False, requires=None) -%}
{{ name }}_service:
  file.managed:
    - name: /etc/systemd/system/{{ name }}.{{ unit_type }}
    - mode: '0644'
    - source: {{ source }}

{{ name }}_daemon_reload:
  cmd.run:
    - name: systemctl daemon-reload
    - onchanges:
      - file: {{ name }}_service

{{ name }}_enabled:
  service.enabled:
    - name: {{ name }}
    - require:
      - cmd: {{ name }}_daemon_reload
{%- if requires %}
{%- for req in requires %}
      - {{ req }}
{%- endfor %}
{%- endif %}

{%- if running %}
{{ name }}_running:
  service.running:
    - name: {{ name }}
    - watch:
      - file: {{ name }}_service
    - require:
      - service: {{ name }}_enabled
{%- endif %}
{%- endmacro -%}
